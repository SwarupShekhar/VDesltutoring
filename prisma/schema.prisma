generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model users {
  id                String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  clerkId           String?             @unique
  email             String              @unique
  full_name         String
  role              user_role?          @default(LEARNER)
  profile_image_url String?
  is_active         Boolean?            @default(true)
  last_login        DateTime?           @db.Timestamptz(6)
  created_at        DateTime?           @default(now()) @db.Timestamptz(6)
  notifications     notifications[]
  student_profiles  student_profiles?
  tutor_profiles    tutor_profiles?
  fluency_sessions  fluency_sessions[]  @relation("UserFluency")
  ai_chat_sessions  ai_chat_sessions[]
  fluency_snapshots fluency_snapshots[]
  coach_memory        Json?
  live_queue          live_queue[]
  live_sessions_as_a  live_sessions[]     @relation("LiveSessionUserA")
  live_sessions_as_b  live_sessions[]     @relation("LiveSessionUserB")
  live_transcripts    live_transcripts[]
  live_metrics        live_metrics[]
  live_session_summaries live_session_summary[]
  live_weaknesses     live_weaknesses[]
  live_micro_fixes    live_micro_fixes[]
  daily_plans         user_daily_plan[]
  user_fluency_profile user_fluency_profile?
}

model packages {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name          String
  price_usd     Decimal  @db.Decimal(10, 2)
  credit_amount Int
  is_public     Boolean? @default(true)
}

model sessions {
  id                 String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  student_id         String           @db.Uuid
  tutor_id           String?          @db.Uuid
  start_time         DateTime         @db.Timestamptz(6)
  end_time           DateTime         @db.Timestamptz(6)
  status             session_status?  @default(SCHEDULED)
  livekit_room_id    String?          @unique
  meeting_link       String?
  admin_notes        String?
  created_at         DateTime?        @default(now()) @db.Timestamptz(6)
  completion_notes   String?
  student_join_time  DateTime?        @db.Timestamptz(6)
  student_leave_time DateTime?        @db.Timestamptz(6)
  tutor_join_time    DateTime?        @db.Timestamptz(6)
  tutor_leave_time   DateTime?        @db.Timestamptz(6)
  student_profiles   student_profiles @relation(fields: [student_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  tutor_profiles     tutor_profiles?  @relation(fields: [tutor_id], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@index([start_time], map: "idx_sessions_start_time")
  @@index([student_id], map: "idx_sessions_student")
  @@index([tutor_id], map: "idx_sessions_tutor")
}

model student_profiles {
  id               String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id          String?    @unique @db.Uuid
  credits          Int        @default(0)
  primary_tutor_id String?    @db.Uuid
  learning_goals   String?
  sessions         sessions[]
  users            users?     @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
}

model tutor_profiles {
  id                     String               @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id                String?              @unique @db.Uuid
  bio                    String?
  expertise_tags         String[]
  hourly_rate_equivalent Int?                 @default(1)
  sessions               sessions[]
  tutor_availability     tutor_availability[]
  users                  users?               @relation(fields: [user_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([expertise_tags], map: "idx_tutor_tags", type: Gin)
}

model tutor_availability {
  id             String          @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tutor_id       String?         @db.Uuid
  day_of_week    Int?
  start_time     DateTime        @db.Time(6)
  end_time       DateTime        @db.Time(6)
  tutor_profiles tutor_profiles? @relation(fields: [tutor_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([tutor_id, day_of_week, start_time])
}

model idempotency_records {
  id                String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  key               String   @unique
  operation         String
  user_id           String
  request_data_hash String
  response_data     Json?
  status_code       Int
  expires_at        DateTime @db.Timestamptz(6)
  created_at        DateTime @default(now()) @db.Timestamptz(6)

  @@index([key], map: "idx_idempotency_key")
  @@index([expires_at], map: "idx_idempotency_expires")
}

model audit_logs {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id       String?
  user_type     String?
  action        String
  event_type    String
  resource_id   String?
  resource_type String?
  details       Json?
  ip_address    String?
  user_agent    String?
  created_at    DateTime @default(now()) @db.Timestamptz(6)

  @@index([user_id], map: "idx_audit_user")
  @@index([event_type], map: "idx_audit_event_type")
  @@index([resource_id], map: "idx_audit_resource")
  @@index([created_at], map: "idx_audit_created_at")
}

model notifications {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id    String   @db.Uuid
  title      String
  message    String
  is_read    Boolean  @default(false)
  created_at DateTime @default(now()) @db.Timestamptz(6)
  users      users    @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id], map: "idx_notifications_user")
}

model fluency_sessions {
  id            String   @id @default(uuid())
  user_clerk_id String
  average_score Float
  rounds        Json
  created_at    DateTime @default(now())

  user users @relation("UserFluency", fields: [user_clerk_id], references: [clerkId])
}

enum session_status {
  SCHEDULED
  LIVE
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum user_role {
  ADMIN
  TUTOR
  LEARNER
}

model ai_chat_sessions {
  id               String             @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id          String             @db.Uuid
  fluency_score    Float?
  grammar_score    Float?
  vocabulary_score Float?
  feedback_summary String?
  started_at       DateTime           @default(now()) @db.Timestamptz(6)
  ended_at         DateTime?          @db.Timestamptz(6)
  messages         ai_chat_messages[]
  users            users              @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id], map: "idx_ai_chat_user")
}

model ai_chat_messages {
  id         String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  session_id String           @db.Uuid
  role       String // "user" or "assistant"
  content    String
  timestamp  DateTime         @default(now()) @db.Timestamptz(6)
  session    ai_chat_sessions @relation(fields: [session_id], references: [id], onDelete: Cascade)

  @@index([session_id], map: "idx_ai_chat_session")
}

model fluency_snapshots {
  id          String   @id @default(uuid())
  user_id     String   @db.Uuid
  user        users    @relation(fields: [user_id], references: [id])

  hesitation            Int
  fillers               Int
  pronunciation         Int
  grammar_scaffold      Int
  translation_thinking Int
  wpm                   Int      @default(0)
  word_count            Int      @default(0)

  created_at DateTime @default(now())
}

model live_queue {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id       String   @unique @db.Uuid
  fluency_score Float
  goal          String
  joined_at     DateTime @default(now()) @db.Timestamptz(6)
  users         users    @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

model live_sessions {
  id         String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  room_name  String
  user_a     String              @db.Uuid
  user_b     String              @db.Uuid
  status     live_session_status @default(waiting)
  started_at DateTime            @default(now()) @db.Timestamptz(6)
  ended_at   DateTime?           @db.Timestamptz(6)
  
  user_a_rel users               @relation("LiveSessionUserA", fields: [user_a], references: [id], onDelete: Cascade)
  user_b_rel users               @relation("LiveSessionUserB", fields: [user_b], references: [id], onDelete: Cascade)

  transcripts live_transcripts[]
  metrics     live_metrics[]
  summaries   live_session_summary[]
  weaknesses  live_weaknesses[]
  micro_fixes live_micro_fixes[]
}

model live_transcripts {
  id         String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  session_id String        @db.Uuid
  user_id    String        @db.Uuid
  text       String
  word_data  Json?         // Array of {word, start, end, confidence}
  timestamp  DateTime      @default(now()) @db.Timestamptz(6)
  
  session    live_sessions @relation(fields: [session_id], references: [id], onDelete: Cascade)
  user       users         @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

enum live_session_status {
  waiting
  live
  ended
}

model live_metrics {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  session_id      String   @db.Uuid
  user_id         String   @db.Uuid
  speaking_time   Float    @default(0) // in seconds
  word_count      Int      @default(0)
  hesitation_count Int     @default(0)
  filler_count    Int      @default(0)
  grammar_errors  Int      @default(0)
  speech_rate     Float    @default(0) // words per minute
  
  // New Audio-First Metrics
  avg_pause_ms             Float?    @default(0)
  mid_sentence_pause_ratio Float?    @default(0)
  pause_variance           Float?    @default(0)
  speech_rate_variance     Float?    @default(0)
  recovery_score           Float?    @default(0)

  updated_at      DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  session         live_sessions @relation(fields: [session_id], references: [id], onDelete: Cascade)
  user            users         @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([session_id, user_id])
}

model live_session_summary {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  session_id      String   @db.Uuid
  user_id         String   @db.Uuid
  confidence_score Float   @default(0)
  confidence_band  String?  // "Low" | "Medium" | "High"
  confidence_explanation String?
  fluency_score   Float    @default(0)
  weaknesses      Json     // Array of strings ["HESITATION", "SPEED"]
  drill_plan      Json     // Array of objects [{exercise: "...", weakness: "..."}]
  created_at      DateTime @default(now()) @db.Timestamptz(6)

  session         live_sessions @relation(fields: [session_id], references: [id], onDelete: Cascade)
  user            users         @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([session_id, user_id])
}

model live_weaknesses {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  session_id  String   @db.Uuid
  user_id     String   @db.Uuid
  tag         String   // HESITATION, SPEED, TENSE, CONFIDENCE, VOCAB
  severity    Float    @default(0)
  created_at  DateTime @default(now()) @db.Timestamptz(6)

  session     live_sessions @relation(fields: [session_id], references: [id], onDelete: Cascade)
  user        users         @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

model live_micro_fixes {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  session_id      String   @db.Uuid
  user_id         String   @db.Uuid
  category        String   // Vocabulary, Connectors, Nuance
  detected_words  Json     // Array of detected basic words
  upgrades        Json     // Array of suggested upgrades
  explanation     String   // Why this is a ceiling
  target_level    String   // CEFR level they're attempting (B1, B2, C1, C2)
  current_limit   String   // CEFR level they're stuck at (A2, B1, B2, C1)
  created_at      DateTime @default(now()) @db.Timestamptz(6)

  session         live_sessions @relation(fields: [session_id], references: [id], onDelete: Cascade)
  user            users         @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([session_id, user_id], map: "idx_micro_fixes_session_user")
}


model fluency_exercises {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  weakness_tag String
  prompt       String
  difficulty   String
  created_at   DateTime @default(now()) @db.Timestamptz(6)
  
  daily_plans  user_daily_plan[]
}

model user_daily_plan {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id     String   @db.Uuid
  date        DateTime @db.Date // Store just the date part ideally, or timestamp
  exercise_id String   @db.Uuid
  status      String   @default("pending") // pending, completed
  created_at  DateTime @default(now()) @db.Timestamptz(6)

  user        users             @relation(fields: [user_id], references: [id], onDelete: Cascade)
  exercise    fluency_exercises @relation(fields: [exercise_id], references: [id], onDelete: Cascade)
}

model blog_posts {
  id        String   @id @default(uuid())
  title     String
  slug      String   @unique
  content   String   // HTML from Tiptap or Markdown
  cover     String?
  status    String   // draft | published
  author_id String
  views     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model user_fluency_profile {
  user_id           String   @id @db.Uuid
  cefr_level        String
  fluency_score     Float
  confidence        Float
  confidence_band   String?  // "Low" | "Medium" | "High"
  confidence_explanation String?
  
  pause_ratio       Float
  avg_pause_ms             Float?    @default(0)
  mid_sentence_pause_ratio Float?    @default(0)
  pause_variance           Float?    @default(0)
  speech_rate_variance     Float?    @default(0)
  recovery_score           Float?    @default(0)

  word_count        Int
  last_updated      DateTime @updatedAt

  lexical_blockers  Json?
  source_session_id String?
  source_type       String // "ai_tutor" | "live_practice"

  user              users    @relation(fields: [user_id], references: [id])
}

